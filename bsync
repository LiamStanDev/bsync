#!/usr/bin/env bash

set -euo pipefail # Exit on error, undefined vars, pipe failures

# Configuration
readonly SCRIPT_NAME="${0##*/}"
readonly DEFAULT_EXCLUDES=(".git/" "node_modules/" ".idea/" ".vscode/" "*.log" "build/" "dist/")
readonly TEMP_FILE_PATTERNS=("*~" "*.swp" "*.tmp" ".#*" "#*#" "4913" ".DS_Store")
readonly DEBOUNCE_TIME=1 # seconds to wait before syncing

# Colors
readonly RED="\e[38;2;255;0;0m"
readonly GREEN="\e[38;2;128;255;128m"
readonly YELLOW="\e[33m"
readonly BLUE="\e[34m"
readonly RESET="\e[0m"

# Global variables
declare -a EXCLUDE_ARGS=()
declare -a ALL_EXCLUDES=()
declare VERBOSE=false
declare DRY_RUN=false
declare IGNORE_FILE=".gitignore"
declare -a ADDITIONAL_EXCLUDES=()
declare NO_INITIAL_SYNC=false
declare WATCH_ONLY=false
declare REMOTE_DIR=""
declare LOCAL_DIR=""
declare SYNC_IN_PROGRESS=false
declare LAST_CHANGE_TIME=0

# Logging functions
log_info() { printf "${BLUE}[INFO]${RESET} %s\n" "$*"; }
log_success() { printf "${GREEN}[DONE]${RESET} %s\n" "$*"; }
log_warning() { printf "${YELLOW}[WARN]${RESET} %s\n" "$*"; }
log_error() { printf "${RED}[FAIL]${RESET} %s\n" "$*" >&2; }
log_verbose() { [[ "$VERBOSE" == true ]] && log_info "$@"; }

show_help() {
  cat <<EOF
Usage: $SCRIPT_NAME [OPTIONS] [REMOTE_DIR]

A file synchronization tool using inotify and rsync.

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -d, --dry-run       Show what would be synced without actually doing it
    -i, --ignore-file   Specify custom ignore file (default: .gitignore)
    -e, --exclude       Add additional exclude pattern
    --no-initial-sync   Skip initial sync
    --watch-only        Only watch for changes, don't sync

ARGUMENTS:
    REMOTE_DIR         Remote directory (username@host:/path/to/dir)
                      If not provided, will prompt for input

EXAMPLES:
    $SCRIPT_NAME user@server:/home/user/project
    $SCRIPT_NAME --dry-run --verbose user@server:/home/user/project
    $SCRIPT_NAME --exclude="*.log" --exclude="build/" user@server:/home/user/project

EOF
}

check_dependencies() {
  local missing=()

  command -v inotifywait &>/dev/null || missing+=("inotify-tools")
  command -v rsync &>/dev/null || missing+=("rsync")

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing dependencies: ${missing[*]}"
    log_error "Please install the required packages."
    exit 1
  fi
}

validate_directories() {
  # Check local directory
  if [[ ! -d "$LOCAL_DIR" ]]; then
    log_error "Local directory does not exist: $LOCAL_DIR"
    exit 1
  fi

  if [[ ! -r "$LOCAL_DIR" ]]; then
    log_error "No read permission for local directory: $LOCAL_DIR"
    exit 1
  fi

  # Validate remote directory format
  if [[ ! "$REMOTE_DIR" =~ ^[^@]+@[^:]+:.+ ]]; then
    log_error "Invalid remote directory format. Expected: username@host:/path"
    exit 1
  fi

  # Test remote connectivity
  local remote_host="${REMOTE_DIR%:*}"
  log_verbose "Testing connection to $remote_host..."
  if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$remote_host" true 2>/dev/null; then
    log_error "Cannot connect to remote host: $remote_host"
    log_error "Please check SSH configuration and connectivity"
    exit 1
  fi
}

build_all_excludes() {
  ALL_EXCLUDES=()

  # Add default excludes
  ALL_EXCLUDES+=("${DEFAULT_EXCLUDES[@]}")

  # Add additional excludes from command line
  ALL_EXCLUDES+=("${ADDITIONAL_EXCLUDES[@]}")

  # Parse ignore file (gitignore format)
  if [[ -f "$IGNORE_FILE" ]]; then
    local line
    while IFS= read -r line; do
      # Skip empty lines and comments
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

      # Clean up the pattern
      line="${line#/}"      # Remove leading slash
      line="${line%/}"      # Remove trailing slash
      line="${line// /\\ }" # Escape spaces

      [[ -n "$line" ]] && ALL_EXCLUDES+=("$line")
    done <"$IGNORE_FILE"
  fi

  log_verbose "Built ${#ALL_EXCLUDES[@]} exclude patterns"
}

build_exclude_args() {
  EXCLUDE_ARGS=()
  for exclude in "${ALL_EXCLUDES[@]}"; do
    EXCLUDE_ARGS+=("--exclude=$exclude")
  done
}

is_temp_file() {
  local filename="$1"
  local pattern
  for pattern in "${TEMP_FILE_PATTERNS[@]}"; do
    if [[ "$filename" == $pattern ]]; then
      return 0
    fi
  done
  return 1
}

should_exclude_file() {
  local filepath="$1"
  local pattern
  for pattern in "${ALL_EXCLUDES[@]}"; do
    if [[ "$filepath" == $pattern || "$filepath" =~ $pattern ]]; then
      return 0
    fi
  done
  return 1
}

sync_files() {
  # Prevent concurrent syncs
  if [[ "$SYNC_IN_PROGRESS" == true ]]; then
    log_verbose "Sync already in progress, skipping..."
    return 0
  fi

  SYNC_IN_PROGRESS=true
  local -a rsync_cmd=("rsync" "-az" "--delete" "--timeout=30")

  [[ "$VERBOSE" == true ]] && rsync_cmd+=("-v")
  [[ "$DRY_RUN" == true ]] && rsync_cmd+=("--dry-run")

  rsync_cmd+=("${EXCLUDE_ARGS[@]}")
  rsync_cmd+=("$LOCAL_DIR/" "$REMOTE_DIR")

  log_verbose "Executing: ${rsync_cmd[*]}"

  local exit_code=0
  "${rsync_cmd[@]}" || exit_code=$?

  SYNC_IN_PROGRESS=false
  return $exit_code
}

get_remote_directory() {
  if [[ -z "$REMOTE_DIR" ]]; then
    printf "${BLUE}Enter remote directory (username@remotehost:/path/to/remote/dir): ${RESET}"
    read -r REMOTE_DIR
  fi

  if [[ -z "$REMOTE_DIR" ]]; then
    log_error "Remote directory cannot be empty"
    exit 1
  fi
}

perform_initial_sync() {
  [[ "$NO_INITIAL_SYNC" == true || "$WATCH_ONLY" == true ]] && return 0

  local answer
  printf "${BLUE}Perform initial sync? (y/n): ${RESET}"
  read -r answer

  if [[ $answer =~ ^[yY] ]]; then
    log_warning "Performing initial sync..."
    if sync_files; then
      log_success "Initial sync completed successfully."
    else
      log_error "Initial sync failed. Check settings and try again."
      exit 1
    fi
  else
    log_success "Skipping initial sync."
  fi
}

build_inotify_exclude() {
  local exclude_pattern=""
  local first=true

  if [[ ${#ALL_EXCLUDES[@]} -gt 0 ]]; then
    exclude_pattern="("
    for exclude in "${ALL_EXCLUDES[@]}"; do
      if [[ "$first" == true ]]; then
        first=false
      else
        exclude_pattern+="|"
      fi
      # Escape special regex characters and remove trailing slashes
      exclude="${exclude%/}"
      exclude="${exclude//./\\.}"
      exclude="${exclude//\*/.*}"
      exclude_pattern+="$exclude"
    done
    exclude_pattern+=")"
  fi

  printf "%s" "$exclude_pattern"
}

debounced_sync() {
  local current_time
  current_time=$(date +%s)
  LAST_CHANGE_TIME=$current_time

  # Wait for debounce period
  sleep "$DEBOUNCE_TIME"

  # Check if any new changes occurred during debounce period
  if [[ $LAST_CHANGE_TIME -eq $current_time ]]; then
    sync_files
  fi
}

monitor_and_sync() {
  local inotify_exclude
  inotify_exclude=$(build_inotify_exclude)

  log_info "Monitoring for changes... (Press Ctrl+C to exit)"

  local inotify_cmd=(inotifywait -mr -e close_write -e delete -e move)
  [[ -n "$inotify_exclude" ]] && inotify_cmd+=(--exclude "$inotify_exclude")
  inotify_cmd+=("$LOCAL_DIR")

  "${inotify_cmd[@]}" |
    while read -r directory events filename; do
      # Skip temp files
      if is_temp_file "$filename"; then
        log_verbose "Ignoring temp file: $filename"
        continue
      fi

      # Check if file should be excluded
      local full_path="${directory}${filename}"
      local relative_path="${full_path#$LOCAL_DIR/}"
      if should_exclude_file "$relative_path"; then
        log_verbose "Ignoring excluded file: $relative_path"
        continue
      fi

      # Watch-only mode
      if [[ "$WATCH_ONLY" == true ]]; then
        log_info "Change detected: ${directory}${filename} (${events})"
        continue
      fi

      log_verbose "Change detected: ${directory}${filename} (${events})"

      # Perform debounced sync in background
      debounced_sync &
    done
}

parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -v | --verbose)
      VERBOSE=true
      shift
      ;;
    -d | --dry-run)
      DRY_RUN=true
      shift
      ;;
    -i | --ignore-file)
      if [[ -z "${2:-}" ]]; then
        log_error "Option $1 requires an argument"
        exit 1
      fi
      IGNORE_FILE="$2"
      shift 2
      ;;
    -e | --exclude)
      if [[ -z "${2:-}" ]]; then
        log_error "Option $1 requires an argument"
        exit 1
      fi
      ADDITIONAL_EXCLUDES+=("$2")
      shift 2
      ;;
    --no-initial-sync)
      NO_INITIAL_SYNC=true
      shift
      ;;
    --watch-only)
      WATCH_ONLY=true
      shift
      ;;
    -*)
      log_error "Unknown option: $1"
      show_help
      exit 1
      ;;
    *)
      if [[ -z "$REMOTE_DIR" ]]; then
        REMOTE_DIR="$1"
      else
        log_error "Too many arguments"
        show_help
        exit 1
      fi
      shift
      ;;
    esac
  done
}

main() {
  parse_arguments "$@"
  check_dependencies

  LOCAL_DIR=$(pwd)
  log_info "Local working directory: $LOCAL_DIR"

  get_remote_directory
  log_info "Remote directory: $REMOTE_DIR"

  validate_directories
  build_all_excludes
  build_exclude_args
  perform_initial_sync

  [[ "$WATCH_ONLY" == true ]] && log_warning "Watch-only mode: monitoring changes but not syncing."

  monitor_and_sync
}

# Cleanup on exit
cleanup() {
  log_info "Cleaning up and exiting..."
  # Kill any background sync processes
  jobs -p | xargs -r kill 2>/dev/null || true
  exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
